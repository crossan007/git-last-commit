/**
 * Adapted from https://github.com/seymen/git-last-commit
 */
 const process = require('child_process');
 const executeCommand = (command, options) => {
   return new Promise((resolve,reject) =>{
     process.exec(command, {}, function(err, stdout, stderr) {
       if (stderr) {
         reject(stderr)
         return
       }
       resolve(stdout)
     })
   });
 }
 
 const getLog = async () =>{
   const splitCharacter = '<##>';
   const LogAttributes = [
     {symbol: "%h", name: "shortHash"}, 
     {symbol: "%H", name: "hash"}, 
     {symbol: "%s", name: "subject"}, 
     {symbol: "%f", name: "sanitizedSubject"}, 
     {symbol: "%b", name: "body"}, 
     {symbol: "%at", name: "authoredOn"}, 
     {symbol: "%ct", name: "committedOn"}, 
     {symbol: "%an", name: "author.name"}, 
     {symbol: "%ae", name: "author.email"}, 
     {symbol: "%cn", name: "committer.name"}, 
     {symbol: "%ce", name: "committer.email"}, 
     {symbol: "%N", name: "notes"}
   ]
   const command =  'git log -1 --pretty=format:"' + LogAttributes.map(f=>f.symbol).join(splitCharacter) +'"';
   const res = await executeCommand(command);
   let response = {};
   res.split(splitCharacter).forEach((d,i,a) => {
     const keyName = LogAttributes[i].name
     if (keyName.includes(".")) {
       const s = keyName.split(".")
       response [s[0]] = {
         [s[1]]: s
       }
     }
     else {
       response[keyName] = d;
     }
   })
 
   return response
 }
 
 const getHead = async ()=> {
   const command =  'git rev-parse --abbrev-ref HEAD'
   return (await executeCommand(command)).split("\n").filter(n=>n)[0]
 }
 
 const getTags = async ()=> {
   const command =  'git tag --contains HEAD'
   return (await executeCommand(command)).split("\n").filter(n=>n)
 }
 
 const getStatus = async() => {
   const command =  'git status --porcelain'
   const status = (await executeCommand(command)).split("\n").filter(n=>n)
   return status;
 }
 
 const getRepoInfo = async () => {
   const [commit, head, tag, status] = await Promise.all([
     getLog(),
     getHead(),
     getTags(),
     getStatus()
   ]);
   const o = {
     commit: commit,
     head: head,
     tags: tag,
     status: status,
     isDirty: status.length > 0
   }
   return o;
 }

 /**
  * Gets the diff of the current working copy against an upstream branch;
  * returns an array of diff objects with the filenames, extended headers, and patchbody
  * as properties on the object.
  * 
  * @param {string} upstream The upstream branch against which the working copy should be diff'd
  * @returns 
  */
 async function getPatches(upstream)  {
  return new Promise((resolve,reject) => {
    let patch_buffer = ""
    
    const child = process.spawn('git', [`diff ${upstream}`], { shell: true})

    child.stdout.setEncoding('utf8');
    child.stdout.on('data', function(data) {
      patch_buffer += data
    });

    child.on('close', function(code) {
      const patchHeaderRegex = new RegExp(/(diff --git a\/.*? b\/.*?\n)/)
      const patches_split = patch_buffer.split(patchHeaderRegex)
        .filter(n=>n)
        .map((element,index,array) => {
          if (index % 2 == 0) {
            return;
          }
          return array[index-1] + element
        })
        .filter(n=>n)
  
      //log("split ", patches_split)
      const patches_parsed = patches_split.map((s)=> {
        const patchRegex = new RegExp(/^diff --git a\/(?<fileA>.*?) b\/(?<fileB>.*?)$\n^(?<extendedHeaders>[\s\S]+?)\n^--- a?(?<fileRemoved>\/.*?)$\n^\+\+\+ b?(?<fileAdded>\/.*?)$\n^(?<patchBody>[\s\S]*)/im)
        const match_result = patchRegex.exec(s);
        if (!match_result) {
          return;
        }
        const { fileA, fileB, extendedHeaders, fileRemoved,fileAdded, patchBody} = match_result.groups
        return {
          fileA: fileA,
          fileB: fileB,
          extendedHeaders: extendedHeaders?.split('\n').filter(n=>n),
          patchBody: patchBody
        }
      })
      .filter(n=>n)
      resolve(patches_parsed);
    });   
  })
}

/**
 * Gets all instances of "todo" in comment lines
 * checks whether a JIRA-like key exists on the TODO line
 * 
 * a todo line may be ignored by placing @ci-ignore anywhere in the line.
 * 
 * @param {*} patches an array of patches generated by `getPatches`
 * @returns 
 */
async function getTodos(patches, jiraProjectKey) {  /** */
  let todos = []
  patches.forEach((p) => {
    /** This regex starts with a postitive lookahead to ensure that the 
     * diff line contains something that looks like a TODO inside a comment block, @ci-ignore 
     * and then parses out both the operation (added/removed) and the todo text @ci-ignore 
     * from the line
     */
    const todoLinesRegex = new RegExp(/(?!.*?ci-ignore.*?)(?=(?:(?:^[\+-]\s+[\/\*]+)|(?:.*?\/[\/\*])).*?todo)(?<operation>^[\+-])\s.*?[\/\*]+.*?(?<todoText>todo.*?)*$/gim)
    while ((matchLine = todoLinesRegex.exec(p.patchBody)) !== null ) {
      const { operation, todoText } = matchLine.groups
      const todo = {
        operation: operation,
        file: p.fileA,
        todoLine: todoText,
        jiraStories: []
      }
      todoHasJIRA = new RegExp(`(${jiraProjectKey}-\\d+)`,"gim")
      while((hasJira = todoHasJIRA.exec(todoText)) !== null) {
        todo.jiraStories.push((hasJira[1]).toUpperCase())
      }
      if (todos.filter(t=>t.file != todo.file && t.todoLine == todo.todoline)){

      }
      todos.push(todo)
    }
  })
   
  return todos
}


const formatTodos = (todos)=> todos.map(t=>(
    (t.jiraStories.length>0 ? ( "["+t.jiraStories.join(" ")+"]") : "[NO JIRA]") + 
    " " + t.file+": " + t.todoLine
  )).join("\n")


 
 module.exports = {
   getRepoInfo,
   getPatches,
   getTodos,
   formatTodos
 }
 